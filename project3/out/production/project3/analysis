// Written by Sofia Kan, kan00022

Method                         ArrayList Runtime          LinkedList Runtime         Explanation
boolean add(T element)         O(1)-average, O(n)-worst   O(1)-average, O(n)-worst   O(n) in Array when resizing is required, in Linked -  if you have to traverse the list to find the end; adding element to ArrayList is a constant time operation, as it involves adding an element at the end of an array; however, once the underlying array is full, it must be resized, and every element must be copied to new array. In LinkedList if you maintain a reference to the last node, adding element at the end is a constant time operation because you don't need to traverse the list.
T getMax()                     O(n)                       O(n)                       For both lists: n is number of elements in the list; to find maximum value, you must traverse each element in the list and compare it with current maximum; this operation requires linear time since every element must be visited.
intersect(List<T> otherList)   O(n*m)                     O(n*m)                     For both lists: n is size of a List and m is size of otherList; intersection requires comparing each element of one list to every element of the other list unless sorting optimization is applied, so runtime is quadratic.
reverse()                      O(n)                       O(n)                       For both lists: n is the number of elements in the list; reversing ArrayList can be done by swapping elements from both ends towards the center, which requires visiting approx half of the elements in the list; reversing LinkedList involves changing the direction of each node pointers; you will have to visit each node once, so it is linear time.